#
# Defining the command line arguments
#

import argparse

arg_parser = argparse.ArgumentParser(description='Wrapping g++ code (gccxml output)  in AMILab.')

arg_parser.add_argument('xmlfilename',                      \
  help='name of xml file generated by gccxml' )

#arg_parser.add_argument('headerfile',                       help='name of file to include, used by gccxml' )

arg_parser.add_argument('--available_classes', nargs='*',  default=[],  \
  help='Lists available classes' )

arg_parser.add_argument('--available_classes_file',  default='',  \
  help='File containing the list available classes' )

arg_parser.add_argument('--classes_includes',  default='',  \
  help='Manually defined includes for certain classes' )

arg_parser.add_argument('--members_blacklist',  default='',  \
  help='Manually discard a set of class function members' )

arg_parser.add_argument('--enum_filter',  default='',  \
  help='Filtering enumerations to add (mainly global enumerations)' )

arg_parser.add_argument('--available_external_classes', nargs='*',  default=[],  \
  help='Lists available classes from another library' )

arg_parser.add_argument('--external_dllname',  default='',  \
  help='dllname for external classes' )

arg_parser.add_argument('--available_external_classes2', nargs='*',  default=[],  \
  help='Lists available classes from a second other library' )

arg_parser.add_argument('--external_dllname2',  default='',  \
  help='dllname for classes of second external lib' )

# ---- Classes, functions, method pointers to wrap 

arg_parser.add_argument('--classes', nargs='*',  default=[],  \
  help='name of the class(es) to wrap' )

arg_parser.add_argument('--functions', nargs='*', default=[],  \
  help='name of the function(s) to wrap' )

arg_parser.add_argument('--methodpointers', nargs='*', default=[], \
  help='name of the method pointers to wrap' )

# ----

arg_parser.add_argument('--classes_file',        default='',  \
  help='file containing the name of the class(es) to wrap' )

arg_parser.add_argument('--functions_file',      default='',  \
  help='file containing the name of the function(s) to wrap' )

arg_parser.add_argument('--methodpointers_file', default='', \
  help='file containing the name of the method pointer(s) to wrap' )

# ----

arg_parser.add_argument('--available_functions', nargs='*', default=[],  \
  help='name of the available wrapped function(s)' )

arg_parser.add_argument('--available_functions_file',  default='',  \
  help='File containing the list of the available wrapped function(s)' )

arg_parser.add_argument('--wrap_includes', nargs='*',  default=[],  \
  help='directories where are the available wrapped classes' )

arg_parser.add_argument('--outputdir', default='wrap/',             \
  help='output directory' )

arg_parser.add_argument('--outputhtmldir', default='html/',             \
  help='Html output directory' )

arg_parser.add_argument('--url', default='http:://',             \
  help='Sets the URL' )

arg_parser.add_argument('--generate-html',action='store_true',  \
  help='Generates the html help file of the class(es) to wrap')

arg_parser.add_argument('-r',       action='store_true',    \
  help='Recursively wrap needed classes')

arg_parser.add_argument('--ancestors',  nargs='*',  default=[],     \
  help='List all ancestors of the given classes')

arg_parser.add_argument('--ancestors-file',   default="ancestors.txt",     \
  help='File to write the list of ancestors.')

arg_parser.add_argument('--overwrite',action='store_true',  \
  help='Overwrite existing wrapped classes')

arg_parser.add_argument('--templates',action='store_true',  \
  help='Wrap template class instances')

arg_parser.add_argument('--profile',action='store_true',  \
  help='Displays the processing time.')

arg_parser.add_argument('--templatefile_dir', default=".",  \
  help='Directory containing the template files (wrap_class.h.in, etc ...)')

arg_parser.add_argument('-q',       
                        action='store_true',    
                        help='Quiet mode')

arg_parser.add_argument('-light',       
                        action='store_true',    
                        help='Disable comments in class members')

arg_parser.add_argument('--filter', default=r'.*',          
                        help='Recursively wrap needed classes')

arg_parser.add_argument('--constructor', default='',        
                        help='Specify the method (static) used for the constructor if it is not the standard one.')

arg_parser.add_argument('--libname',                        
                        help='name of the library to wrap (without spaces or special characters)')

arg_parser.add_argument('--dllname', default='', 
                        help='name of the dll library, to include configuration file and use import/export macros')

arg_parser.add_argument('--addwrap',  action='store_true',  help='Generates the addwrap_*.{h,cpp} files that include all the wrapped elements in a common context')

arg_parser.add_argument('--update', action='store_true',   \
  help='re-generate all currently wrapped classes')

arg_parser.add_argument('--max', type=int,default=500,   \
  help='maximum number of files generated')

arg_parser.add_argument('-gccxml',       action='store_true',    \
  help='Try to generate the xml for the library')

# Parse can it work??
val = arg_parser.parse_args()

# works??
#from args import *

#print "recursive:",val.r
#print "overwrite:",val.overwrite
#print "library name:",val.libname
